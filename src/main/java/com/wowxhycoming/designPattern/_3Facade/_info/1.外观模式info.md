#facade模式（外观模式、门面模式）

##定义
为子系统中的“一组”接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统“更加容易使用”。

##facade的本质
封装交互、简化调用

##注意
只是为客户端包装一个高端接口，子系统内部的模块，完全不知道facade的存在。外部的调用全部委派给facade，由facade代为完成。

##使用场景
1. 为一个复杂子系统提供一个简单接口
2. 提高子系统的独立性
3. 在层次化结构中，可以使用Facade模式定义系统中每一层的入口。

##facade带来的好处
1. 避免子系统内部模块发生变化时（子系统模块的某个方法增加了参数），客户端也要随之改变。
2. 为客户端简单实用子系统，客户端只需要跟facade交互即可，无需关注众多的子系统模块。
3. 屏蔽客户端与子系统内部模块，实现客户端与子系统内部模块的解耦。
4. 实现功能的共享和复用。facade封装好系统内部的细节，提供给客户端调用。
5. 有facade，也可以不适用。facade提供了缺省的实现。
6. 

##facade的实现
1. 一个子系统，只需要一个facade即可，最好用单例实现
2. facade可以实现成为interface，如图：“3.接口形的外观模式.gif”，代码：example2。
2.1. facade实现成为interface附带的好处是，能够有选择性的暴露接口，尽量减少模块对子系统外提供的接口方法。代码：example3。
3. facade的内部代码，只是负责将客户端的请求组装、分发给内部的各个子模块，一般不进行任何逻辑处理，只实现一个功能组合调用。

##facade的优点
1. 松散耦合：客户端和子系统内部的各个模块的耦合关系。
2. 简单易用：客户端只需要与facade进行交互，facade只需提供一个简单应用的借口。
3. 更好的划分访问的层次：interface形式的facade，提供给客户端的方法放到facade中。
4. 隐藏内部细节

##facade的缺点
1. 不要提供过多的facade。

##对设计原则的体现
最少知识原则：客户端知道的越少越好，指导在系统设计时，尽量少的减少对象之间的交互。

##何时选用facade
1. 为一个复杂（只客户端在使用子系统的时候复杂，不是子系统内部复杂）的子系统提供一个简单接口。
2. 想让客户端的程序和抽象类的实现部分松散耦合，从而提高子系统的独立性和可移植性。
3. 如果构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口，这样可以简化层间调用，也可以松散层次之间的依赖关系。

##相关模式
1. 外观模式和中介者模式
这两个模式非常类似，但是有本质的区别。
中介者模式主要用来封装多个对象之间相互的交互，多用在系统内部的多个模块之间；而外观模式封装的是单向的交互，是从客户端访问系统的调用，没有从系统中来访问客户端的调用。
在中介者模式的实现里面，是需要实现具体的交互功能的；而外观模式的实现里面，一般是组合调用或是转调内部实现的功能，通常外观模式本身并不实现这些功能。
中介者模式的目的主要是松散多个模块之间的耦合，把这些耦合关系全部放到中介者中去实现；而外观模式的目的是简化客户端的调用，这点和中介者模式也不同。
2. 外观模式和单例模式
通常一个子系统只需要一个外观实例，所以外观模式可以和单例模式组合使用，把Facade类实现成为单例。当然，也可以跟前面示例的那样，把外观类的构造方法私有化，然后把提供给客户端的方法实现成为静态的。
3.外观模式和抽象工厂模式
    外观模式的外观类通常需要和系统内部的多个模块交互，每个模块一般都有自己的接口，所以在外观类的具体实现里面，需要获取这些接口，然后组合这些接口来完成客户端的功能。
    那么怎么获取这些接口呢？就可以和抽象工厂一起使用，外观类通过抽象工厂来获取所需要的接口，而抽象工厂也可以把模块内部的实现对Facade进行屏蔽，也就是说Facade也仅仅只是知道它从模块中获取的它需要的功能，模块内部的细节，Facade也不知道了。